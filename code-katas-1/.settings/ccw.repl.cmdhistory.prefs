cmdhistory=["(range 2 22)" "(filter-odd 5)" "(range 0 21)" "(range 0 200)" "(filter-odd 2)" "(print \\"pepe\\")" "(filter-odd 5)" "(range 0 20)" "(filter-odd 1)" "(nil-key 5)" "(foo)" "(foo \\"\\")" "(filter-odd 2)" "(range 1 2)" "(require\:reload-all code-katas-1.core)" "(require\:reload-all '(code-katas-1.core))" "(range 2 22)" "(require\:reload-all 'code-katas-1.core)" "(range  1 2)" "(foo \\"\\")" "(range 2 22)" "(require\:reload-all '(code-katas-1.core))" "(range 2 22)" "(foo \\"\\")" "(range 2 22)" "(def list (conj '() 3))" "(print list)" "(def t 6)" "(def list (conj '() t))" "(print list)" "(def list (conj list t))" "(print list)" "(foo \\"\\")" "(range 2 22)" "(def list '(1 2 3 4))" "(print list)" "(reverse list)" "(def list '(2))" "(print list)" "(range 2 22)" "(eval 2\=2)" "(eval \= 2 2)" "(eval ( \= 22 2))" "(eval not ( \= 2 22))" "(eval (not ( \= 22 2)))" "(foo \\"\\")" "(range 0 20)" "(range 2 22)" "(def start 1)" "(def start (inc start))" "(eval start)" "(eval (\=\= start 2))" "(range 2 22)" "(eval (def loops (- 22 2)))" "(print loops)" "(def list '( 1 2 3 3 3 6 4 5))" "(counter list)" "(count list)" "(range 2 22)" "(range 1 10)" "(range 10 15)" "(range 1 0)" "(range 1 10)" "(nil-key 1 10)" "(range 1 10)" "(nil-key [1 2 3])" "(def length 3)" "(dotimes [loops length ] (print loops))" "(dotimes [loops length] (println loops))" "(filter-odd [1 2 3])" "(nth [12 2 3] 0)" "(def t 2%)" "(print 7/3)" "(print 2 mod 2)" "(print (2 mod 2))" "(print 3\\\\2)" "(print 7%2)" "(def t (7%2))" "(print (% 7 2))" "(print % 7 2)" "(print / 7 3)" "(print (/ 7 3))" "(print + 3 2)" "(+ 1 2)" "(% 7 3)" "(/ 7 3)" "(* 7 3)" "(mod 2 3)" "(mod 7 3)" "(mod 8 2)" "(filter-odd [1 2 3])" "  (dotimes [loops length]\\r\\n    (if ((eval (not (\=\= (mod loops 2) 0))));El numero es impar si el resto de la divicion /2 es distinto de cero.\\r\\n      (def list (conj list loops))\\r\\n    )\\r\\n  )" "(range 1 10)" "(dotimes [loops length] (if ((eval (not (\=\= (mod loops 2) 0)))) (print loops)))" "(dotimes [loops length] (if ((eval (not (\=\= (mod (eval loops) 2) 0)))) (print loops)))" "(dotimes [loops length] (if ((eval (not (\= (mod loops 2) 0)))) (print loops)))" "(if ((eval (not (\=\= (mod loops 2) 0)))) (print loops))" "(def loops 8)" "(if ((eval (not (\=\= (mod loops 2) 0)))) (print loops))" "(if ((is (not (\=\= (mod loops 2) 0)))) (print loops))" "(if ((eval (not (\= (mod loops 2) 0)))) (print loops))" "(not (\=\= mod loops 2))" "(not (\=\= (mod loops 2) 0))" "(not (\= (mod loops 2) 0))" "(not (\=\= (mod loops 2) 0))" "(if (not (\=\= (mod loops 2) 0)) (print loops))" "(eval (not (\=\= (mod loops 2) 0)))" "(not (\=\= (mod loops 2) 0))" "(if (not (\=\= (mod loops 2) 0))(print loops))" "(if (not (\=\= (mod loops 2) 0))(println loops))" "(range 1 10)" "(filter-odd [1 2 3])" "(filter-odd (1 2 3))" "(filter-odd [1 2 3])" "(dotimes [loops lentgh] (if( (not (\=\= (mod loops 2) 0))) (def list (conj list aux))))" "(def length 10)" "(dotimes [loops lentgh] (if( (not (\=\= (mod loops 2) 0))) (def list (conj list aux))))" "(dotimes [loops length] (if( (not (\=\= (mod loops 2) 0))) (def list (conj list aux))))" "(dotimes [loops length] (if(not (\=\= (mod loops 2) 0)) (def list (conj list aux))))" "(dotimes [loops length] (if(not (\=\= (mod loops 2) 0)) (def list (conj list aux))) (print list))" "(def aux loops)" "(print aux)" "(eval aux)" "(dotimes [loops length] ( def aux loops) (print aux)(if(not (\=\= (mod loops 2) 0)) (def list (conj list aux))) (print list))" "( (def list '()) (dotimes [loops length] ( def aux loops) (print aux)(if(not (\=\= (mod loops 2) 0)) (def list (conj list aux))) (print list)))" "( (def list '()) (dotimes [loops length] ( def aux loops) (print aux)(if(not (\=\= (mod loops 2) 0)) (def list (conj list aux)))))" "(dotimes [loops length] ( def aux loops) (print aux)(if(not (\=\= (mod loops 2) 0)) (def list (conj list aux))) (print list))" "(dotimes [loops length] ( def aux loops) (print aux)(if(not (\=\= (mod loops 2) 0)) (def list (conj list aux))))" "(def length (count [1 2 3 4]))" "(def list '())" "(dotimes [loops length] ( def aux loops) (print aux)(if(not (\=\= (mod loops 2) 0)) (def list (conj list aux))))" "(print list)" "(filter-odd [1 2 3])" "(filter-odd [ 1 3 5 7])" "(filter-odd [1 3 4 5 6 7 8 9])" "(filter-odd \#{1 2 3 4 5})" "(filter-odd [4 2 1 6])" "(filter-odd [2 2 4 6])" "(filter-odd [1 1 1 3])" "(require 'code-katas-1.core-test)" "(in-ns 'code-katas-1.core-test)" "(run-tests)" "(def {1 2 3 3})" "(def aux {1 2 3})" "(def \#{1 2 3 4 5})" "(print \#{1 2, 13,} )" "(print \#{1 2 3 4 5})" "(eval \#{1 2 3 4 5})" "(eval '(1 2 3))" "(count \#{1 2 3 4 5})" "(nth s 5)" "(get \#{1 2 3 4 5})" "(get \#{1 2 3 4 5} 2)" "(filter-odd [1 2 3])" "(get [ 1 2 3] 3)" "(get [ 1 2 3] 2)" "(get \#{1 2 5 3 6 7 9})" "(get \#{1 2 5 3 6 7 9} 5)" "(get \#{ 1 2 5 9} 3)" "(get [1 2 3 4 5] 4)" "(get [1 2 3 4 5] 3)" "(get [1 2 3 4 5] 2)" "(get [1 2 3 4 5] 1)" "(get [1 2 3 4 5] 0)" "(get [1 2 3 4 5] -1)" "(get \#{1 2 3 4 5} 4)" "(get \#{1 2 3 4 5} 0)" "(filter-odd \#{1 2 3 4 5} 0)" "(filter-odd \#{1 2 3 4 5})" "(filter-odd [1 2 3])" "(filter-odd [])" "(require 'code-katas-1.core-test)" "(in-ns 'code-katas-1.core-test)" "(run-tests)" "(list \#{1 2 3 4 5})" "(def list (quote ( 1,2,3,3)))" "(print list)" "(def list (quote \#{1 2 3 4 5}))" "(print list)" "(seq \#{1 2 3 4 5})" "(def list (seq \#{1 2 3 4 5}))" "(eval list)" "(print list)" "(def l (seq [1 2 3]))" "(print l)" "(filter-odd \#{1 2 3 4 5})" "(filter-odd [1 2 3])" "(filter-odd [1 2 3 4])" "(filter-odd \#{1 2 3 4 5})" "(require 'code-katas-1.core-test)" "(in-ns 'code-katas-1.core-test)" "(run-tests)" "(require 'code-katas-1.core)" "(in-ns 'code-katas-1.core-test)" "(run-tests)" "(require 'code-katas-1.core)" "(range 1 10)" "(filter-odd [1 2 3 5 6])" "(require 'code-katas-1.core-test)" "(in-ns 'code-katas-1.core-test)" "(require 'code-katas-1.core-test)" "(in-ns 'code-katas-1.core-test)" "(run-tests)" "(def map {\:a nil \:b 2})" "(print map)" "(contains? map\: a)" "(contains? map \:a)" "(get map \:a)" "(get map \:b)" "(\=\= (get map \:a) nil)" "(eval (\=\= (get map \:a) nil))" "(isa? (get map\:a) nil)" "(get map \:a)" "( \=(get map \:) nil)" "\=> ( \=(get map \:a) nil)" "\=> ( \=\=(get map \:a) nil)" "\=> (\=(get map \:a) nil)" "(and (contains? m \:k) (\= (get m \:k) nil))" "(and (contains? m \:k) & (\= (get m \:k) nil))" "(and true true)" "(and (contains? m \:k) (\= (get m \:k) nil))" "(contains? m \:k)" "(contains? m k)" "(and (contains? map \:a) & (\= (get map \:a) nil))" "(contains? map \:a)" "(and (contains? map \:a) (\= (get map \:a) nil))" "(def m {\:a nil \:b 2})" "(eval(and (contains? m \:k) (\= (get m \:k) nil)))" "(nil-key \:a m)" "(and (contains? m \:k) (\= (get m \:k) nil))" "(and (contains? m \:a) (\= (get m \:a) nil))" "(def m {\:a nil \:b 2})" "(foo \\"\\")" "(def m {\:a nil \:b 2})" "(nil-key \:a m)" "(def m {\:a nil \:b 2})" "(nil-key \:a m)" "(nil-key \:b m)" "(nil-key \:c m)" "(require 'code-katas-1.core-test)" "(in-ns 'code-katas-1.core-test)" "(run-tests)" "(max-value '(1 2 3 4 5))" "(max-value & '(1 2 3))" "(max-value & '(1 2 3 4 5))" "(max-value \\"1\\" '(1 2 3 4 5))" "(max-value \\"4\\" [1 2 3 4 5])" "(sort '(1 2 3 4 5))" "(sort '(8 7 3 6 5))" "(nth '(3 5 6 7 8) (- (count '(3 5 6 7 8)) 1))" "(require 'code-katas-1.core-test)" "(in-ns 'code-katas-1.core-test)" "(run-tests)" "(max-value [1 2 3 4])" "(require 'code-katas-1.core)" "(require 'code-katas-1.core-test)" "(in-ns 'code-katas-1.core-test)" "(run-tests)" "(require 'code-katas-1.core-test)" "(in-ns 'code-katas-1.core-test)" "(run-tests)" "(true? [true])" "(true? true)" "(every? \#(true? (true true true) %))" "(every? (true true))" "(even? \#(instance? true %) (true true))" "(every? \# (instance? true %) (true true)" "(every? \# (instance? number? %) (true)" "(contains? '(1 2 3 3) 3)" "(some \# (\= true %) '(true true)" "(some \# (\= true %) '(true true true)" "(some \# (\= % true) '(true true true)" "(some \# (\= % true) '(true false true)" "(def list '(\\"mar\\" \\"mares\\"))" "(some \# (\= % true) list" "(contains? (set list) \\"mar\\")" "(def bool '(true true true))" "(contains? (set list) \\"mar\\")" "(every? \# (contains? true %) list" "(every? \# (contains? true %) (set list)" "(set list)" "(list list)" "'(list)" "(every? \# (\=true %) list" "(every? \# (\= true %) list" "(not-any? zero? [ 0 2 1])" "(not-any? true? [true true])" "(not-any? true? ( false true))" "(set [ 1 2 3])" "(seq [1 2 3])" "(vec (1 2 3))" "(vector (1 2 3))" "(vector 1 2 3)" "(vector '())" "(conj [] '(1 2 3))" "(into [] '(1 2 3))" "(not-every? true [ true true true])" "(not-every? true? [ true true true])" "(even? true? [true true])" "(some true? [true true false])" "(eval (and (even? true? [true true false])(some true? [true true false])))" "(eval (and (not-every? true? [true true false])(some true? [true true false])))" "(eval (and (not-every? true? [true true true])(some true? [true true true])))" "(require 'code-katas-1.core-test)" "(in-ns 'code-katas-1.core-test)" "(run-tests)" "(eval (and (not-every? true? [false false])(some true? [false false])))" "(some true? [false])" "(not-every? true?[false])" "(max-value [1 2 3])" "(max-value (1 2 3))"]
eclipse.preferences.version=1
